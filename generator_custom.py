#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Gerador Customizado de Logbook - Usa dados personalizados
Combina dados inseridos pelo usu√°rio com pools autom√°ticos

Uso: python generator_custom.py
"""

from docxtpl import DocxTemplate
import json
from datetime import datetime, timedelta
import random
import os
import sys

class CustomLogbookGenerator:
    def __init__(self):
        """Inicializa o gerador customizado"""
        print("üç≥ GERADOR CUSTOMIZADO DE LOGBOOK")
        print("=" * 50)
        self.config = self.load_json('config.json')
        self.content_pools = self.load_json('content_pools.json')
        self.custom_data = self.load_custom_data()
        
    def load_json(self, filename):
        """Carrega arquivo JSON com tratamento de erro"""
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"‚ùå Erro: Arquivo {filename} n√£o encontrado!")
            print(f"   Certifique-se de que o arquivo existe no diret√≥rio atual.")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"‚ùå Erro: Arquivo {filename} com formato JSON inv√°lido!")
            print(f"   Erro espec√≠fico: {e}")
            sys.exit(1)
    
    def load_custom_data(self):
        """Carrega dados personalizados se existirem"""
        filename = 'shifts_data_custom.json'
        if os.path.exists(filename):
            try:
                with open(filename, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                print(f"‚úÖ Dados personalizados carregados: {len(data)} shifts")
                return {item['shift_number']: item for item in data}
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao carregar dados personalizados: {e}")
                return {}
        else:
            print("‚ö†Ô∏è Arquivo de dados personalizados n√£o encontrado!")
            print("   Execute primeiro: python input_collector.py")
            choice = input("   Continuar com dados autom√°ticos? (s/n): ")
            if choice.lower() != 's':
                sys.exit(1)
            return {}
    
    def generate_shifts(self):
        """Gera dados para todos os 48 shifts (customizados + autom√°ticos)"""
        print("üìä Gerando dados para 48 shifts...")
        shifts = []
        start_date = datetime.strptime(self.config['start_date'], '%Y-%m-%d')
        
        # √çndices para controlar variedade do conte√∫do autom√°tico
        used_content = {
            'special_requests': [],
            'food_details': [],
            'complaints': [],
            'debrief': []
        }
        
        custom_count = 0
        auto_count = 0
        
        for i in range(48):
            shift_number = i + 1
            shift_date = start_date + timedelta(days=i//2)
            shift_type = 'lunch' if i % 2 == 0 else 'dinner'
            
            # Dados b√°sicos (sempre os mesmos)
            shift_data = {
                'shift_number': shift_number,
                'establishment': self.config['establishment'],
                'date': shift_date.strftime('%d/%m/%Y'),
                'shift_type': shift_type.title(),
                'start_time': self.config['shifts'][shift_type]['start_time'],
                'end_time': self.config['shifts'][shift_type]['end_time'], 
                'hours': self.config['shifts'][shift_type]['hours'],
                'menu_style': self.config['menu_style'],
                'workflow': self.content_pools[f'workflow_{shift_type}']
            }
            
            # Verificar se h√° dados customizados para este shift
            if shift_number in self.custom_data:
                # Usar dados customizados
                custom_shift = self.custom_data[shift_number]
                shift_data.update(self.merge_custom_data(custom_shift, shift_type))
                custom_count += 1
                print(f"üìù Shift {shift_number}: dados personalizados")
            else:
                # Usar dados autom√°ticos dos pools
                shift_data.update(self.generate_automatic_data(shift_type, used_content))
                auto_count += 1
                print(f"üé≤ Shift {shift_number}: dados autom√°ticos")
            
            shifts.append(shift_data)
        
        print(f"‚úÖ {len(shifts)} shifts gerados!")
        print(f"   üìù Personalizados: {custom_count}")
        print(f"   üé≤ Autom√°ticos: {auto_count}")
        return shifts
    
    def merge_custom_data(self, custom_shift, shift_type):
        """Combina dados customizados com dados padr√£o"""
        data = {}
        
        # Prepared for service - usar customizado se existir, sen√£o padr√£o
        data['prepared_service'] = custom_shift.get(
            'prepared_service', 
            self.content_pools['prepared_service'][shift_type]
        )
        
        # Campos customizados - usar se existirem, sen√£o usar dos pools
        for field in ['special_requests', 'food_details', 'complaints', 'debrief']:
            if field in custom_shift and custom_shift[field].strip():
                data[field] = custom_shift[field]
            else:
                # Usar pool autom√°tico se campo vazio
                data[field] = random.choice(self.content_pools[field])
        
        return data
    
    def generate_automatic_data(self, shift_type, used_content):
        """Gera dados autom√°ticos dos pools com variedade"""
        data = {
            'prepared_service': self.content_pools['prepared_service'][shift_type],
            'special_requests': self.get_varied_content('special_requests', used_content),
            'food_details': self.get_varied_content('food_details', used_content),
            'complaints': self.get_varied_content('complaints', used_content),
            'debrief': self.get_varied_content('debrief', used_content)
        }
        return data
    
    def get_varied_content(self, content_type, used_content):
        """Seleciona conte√∫do com variedade, evitando repeti√ß√µes excessivas"""
        available_content = self.content_pools[content_type]
        
        # Se todos foram usados, resetar para permitir reutiliza√ß√£o
        if len(used_content[content_type]) >= len(available_content):
            used_content[content_type] = []
        
        # Preferir conte√∫do n√£o usado recentemente
        unused = [item for item in available_content if item not in used_content[content_type]]
        
        if unused:
            selected = random.choice(unused)
        else:
            selected = random.choice(available_content)
        
        # Registrar uso
        used_content[content_type].append(selected)
        
        # Manter apenas os √∫ltimos 3 itens para permitir reutiliza√ß√£o ap√≥s um intervalo
        if len(used_content[content_type]) > 3:
            used_content[content_type].pop(0)
        
        return selected
    
    def format_workflow_table(self, workflow_data):
        """Formata dados do workflow para o template"""
        formatted_rows = []
        for item in workflow_data:
            formatted_rows.append({
                'time': item['time'],
                'task': item['task'],
                'equipment': item['equipment'],
                'communication': item['communication']
            })
        return formatted_rows
    
    def generate_documents(self):
        """Gera todos os documentos Word"""
        print("üöÄ Iniciando gera√ß√£o de documentos...")
        
        # Verificar se template existe
        template_file = 'logbook_template.docx'
        if not os.path.exists(template_file):
            print(f"‚ùå Erro: Arquivo '{template_file}' n√£o encontrado!")
            print("   Crie o template Word primeiro seguindo as instru√ß√µes do PLANO.md")
            return False
        
        try:
            template = DocxTemplate(template_file)
        except Exception as e:
            print(f"‚ùå Erro ao carregar template: {e}")
            return False
        
        # Gerar dados dos shifts
        shifts = self.generate_shifts()
        
        # Criar pasta output se n√£o existir
        output_dir = 'output'
        os.makedirs(output_dir, exist_ok=True)
        print(f"üìÅ Pasta de sa√≠da: {os.path.abspath(output_dir)}")
        
        # Gerar documentos
        success_count = 0
        custom_count = 0
        
        for shift in shifts:
            try:
                # Adicionar workflow formatado
                shift['workflow_table'] = self.format_workflow_table(shift['workflow'])
                
                # Renderizar template com dados do shift
                template.render(shift)
                
                # Salvar arquivo
                filename = f"shift_{shift['shift_number']:02d}_{shift['shift_type'].lower()}.docx"
                filepath = os.path.join(output_dir, filename)
                template.save(filepath)
                
                # Identificar se √© customizado
                is_custom = shift['shift_number'] in self.custom_data
                icon = "üìù" if is_custom else "üé≤"
                print(f"{icon} Gerado: {filename}")
                
                if is_custom:
                    custom_count += 1
                
                success_count += 1
                
                # Recarregar template para pr√≥ximo uso (evita problemas de estado)
                template = DocxTemplate(template_file)
                
            except Exception as e:
                print(f"‚ùå Erro ao gerar shift {shift['shift_number']}: {e}")
                continue
        
        # Relat√≥rio final
        if success_count == 48:
            print(f"\nüéâ SUCESSO TOTAL! {success_count} documentos gerados na pasta '{output_dir}/'")
            print(f"üìä ESTAT√çSTICAS:")
            print(f"   üìù Personalizados: {custom_count}")
            print(f"   üé≤ Autom√°ticos: {48 - custom_count}")
            print(f"   üìÅ Local: {os.path.abspath(output_dir)}")
            print("\nüìù Pr√≥ximos passos:")
            print("   1. Conferir os documentos gerados")
            print("   2. Imprimir e levar para assinatura do head chef")
            print("   3. Completar seu curso com sucesso! üéì")
        else:
            print(f"\n‚ö†Ô∏è Gera√ß√£o parcial: {success_count}/48 documentos criados")
            print("   Verifique os erros acima e execute novamente se necess√°rio")
        
        return success_count == 48
    
    def validate_generated_files(self):
        """Valida se todos os arquivos foram gerados corretamente"""
        output_dir = 'output'
        if not os.path.exists(output_dir):
            print("‚ùå Pasta output n√£o encontrada")
            return False
        
        expected_files = 48
        generated_files = len([f for f in os.listdir(output_dir) if f.endswith('.docx')])
        
        if generated_files == expected_files:
            print(f"‚úÖ Valida√ß√£o: {generated_files} arquivos gerados com sucesso!")
            return True
        else:
            print(f"‚ö†Ô∏è Aviso: Esperados {expected_files}, encontrados {generated_files}")
            return False
    
    def show_statistics(self):
        """Mostra estat√≠sticas dos dados personalizados"""
        total_custom = len(self.custom_data)
        total_auto = 48 - total_custom
        
        print(f"\nüìä ESTAT√çSTICAS:")
        print(f"   Total de shifts: 48")
        print(f"   üìù Personalizados: {total_custom}")
        print(f"   üé≤ Autom√°ticos: {total_auto}")
        print(f"   üìç Estabelecimento: {self.config['establishment']}")
        print(f"   üìÖ Data inicial: {self.config['start_date']}")
        print(f"   ‚è±Ô∏è Per√≠odo: 24 dias")
        
        if total_custom > 0:
            custom_shifts = sorted(self.custom_data.keys())
            print(f"   üìù Shifts personalizados: {custom_shifts}")

def main():
    """Fun√ß√£o principal"""
    print("üç≥ GERADOR CUSTOMIZADO DE LOGBOOK")
    print("=" * 60)
    print("SIT40521 Certificate IV in Kitchen Management")
    print("Combina dados personalizados + autom√°ticos")
    print("=" * 60)
    
    try:
        # Verificar depend√™ncias
        try:
            from docxtpl import DocxTemplate
        except ImportError:
            print("‚ùå Erro: Biblioteca 'python-docx-template' n√£o encontrada!")
            print("   Instale com: pip install python-docx-template")
            sys.exit(1)
        
        # Criar inst√¢ncia do gerador
        generator = CustomLogbookGenerator()
        
        # Mostrar estat√≠sticas
        generator.show_statistics()
        
        # Confirmar gera√ß√£o
        print("\nü§î Deseja gerar os 48 documentos? (s/n): ", end="")
        try:
            response = input().lower().strip()
        except KeyboardInterrupt:
            print("\n\nüëã Opera√ß√£o cancelada pelo usu√°rio")
            sys.exit(0)
        
        if response in ['s', 'sim', 'y', 'yes']:
            # Gerar documentos
            if generator.generate_documents():
                generator.validate_generated_files()
            else:
                print("‚ùå Falha na gera√ß√£o dos documentos")
                sys.exit(1)
        else:
            print("üëã Opera√ß√£o cancelada")
    
    except KeyboardInterrupt:
        print("\n\nüëã Programa interrompido pelo usu√°rio")
        sys.exit(0)
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main() 
